# =============================================================================
# NQR-MicroVM Air-Gapped ISO Build Workflow
# =============================================================================
# This workflow builds the air-gapped ISO for offline installation.
# It is triggered after a release is published.
#
# The ISO includes:
#   - NQR-MicroVM binaries (manager, guest-agent, installer)
#   - Firecracker
#   - Kernel and rootfs images
#   - Docker container images
#   - Required Debian packages
# =============================================================================

name: Build Air-Gapped ISO

on:
  workflow_dispatch:
    inputs:
      release_version:
        description: 'Release version to bundle (e.g., v0.1.64)'
        required: false
        default: 'latest'
  workflow_run:
    workflows: ["Release"]
    types:
      - completed

concurrency:
  group: iso-build-${{ github.ref }}
  cancel-in-progress: true

env:
  CARGO_TERM_COLOR: always

jobs:
  build-iso:
    name: Build Air-Gapped ISO
    runs-on: ubuntu-24.04
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Determine release version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.release_version }}"
          else
            # Get the latest release tag
            VERSION=$(curl -s https://api.github.com/repos/${{ github.repository }}/releases/latest | jq -r '.tag_name')
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Release version: ${VERSION}"

      - name: Free up disk space
        run: |
          echo "=== Disk space before cleanup ==="
          df -h
          
          # Remove unnecessary large packages to free disk space
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /usr/local/lib/android
          sudo rm -rf /opt/ghc
          sudo rm -rf /opt/hostedtoolcache/CodeQL
          sudo rm -rf /usr/local/share/boost
          sudo rm -rf /usr/share/swift
          sudo rm -rf "$AGENT_TOOLSDIRECTORY"
          
          # Clean apt cache
          sudo apt-get clean
          sudo apt-get autoremove -y
          
          # Remove large unused packages
          sudo apt-get remove -y '^dotnet-.*' '^llvm-.*' 'php.*' '^mongodb-.*' '^mysql-.*' azure-cli google-cloud-cli microsoft-edge-stable google-chrome-stable firefox 2>/dev/null || true
          sudo apt-get autoremove -y
          sudo apt-get clean
          
          # Clean docker images
          docker system prune -af 2>/dev/null || true
          
          echo "=== Disk space after cleanup ==="
          df -h

      - name: Install live-build dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            live-build \
            debootstrap \
            xorriso \
            isolinux \
            syslinux \
            syslinux-common \
            syslinux-efi \
            syslinux-utils \
            grub-pc-bin \
            grub-efi-amd64-bin \
            squashfs-tools \
            dosfstools \
            mtools \
            debian-archive-keyring
          
          # Create isohybrid in /usr/bin (live-build scripts use sh and may not have /usr/local/bin in PATH)
          echo "Creating isohybrid wrapper in /usr/bin..."
          printf '#!/bin/sh\nexit 0\n' | sudo tee /usr/bin/isohybrid > /dev/null
          sudo chmod +x /usr/bin/isohybrid
          echo "isohybrid wrapper installed at: $(which isohybrid)"

      - name: Install Docker
        uses: docker/setup-buildx-action@v3

      - name: Download release binaries
        run: |
          mkdir -p /tmp/bundle/bin
          VERSION="${{ steps.version.outputs.version }}"
          
          # Helper function to download with retries
          download_with_retry() {
            local url="$1"
            local output="$2"
            local max_attempts=5
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Download attempt $attempt/$max_attempts: $url"
              if curl -fsSL --retry 3 --retry-delay 5 --retry-all-errors "$url" -o "$output"; then
                echo "Download successful!"
                return 0
              fi
              echo "Attempt $attempt failed, waiting before retry..."
              sleep $((attempt * 5))
              attempt=$((attempt + 1))
            done
            
            echo "ERROR: Failed to download after $max_attempts attempts"
            return 1
          }
          
          # First, fetch available assets from GitHub API
          echo "=== Fetching release assets from GitHub API ==="
          if [[ "${VERSION}" == "latest" ]]; then
            RELEASE_API_URL="https://api.github.com/repos/${{ github.repository }}/releases/latest"
          else
            RELEASE_API_URL="https://api.github.com/repos/${{ github.repository }}/releases/tags/${VERSION}"
          fi
          
          echo "API URL: ${RELEASE_API_URL}"
          ASSETS_JSON=$(curl -fsSL --retry 3 --retry-delay 5 "${RELEASE_API_URL}")
          
          echo "=== Available release assets ==="
          echo "${ASSETS_JSON}" | jq -r '.assets[].name' || echo "Failed to parse assets"
          
          # Get download URL base
          if [[ "${VERSION}" == "latest" ]]; then
            BASE_URL="https://github.com/${{ github.repository }}/releases/latest/download"
          else
            BASE_URL="https://github.com/${{ github.repository }}/releases/download/${VERSION}"
          fi
          
          echo ""
          echo "Download base URL: ${BASE_URL}"
          echo ""
          
          # Find and download manager binary (look for patterns: nqrust-manager*, nqr-manager*)
          echo "=== Downloading manager binary ==="
          MANAGER_ASSET=$(echo "${ASSETS_JSON}" | jq -r '.assets[].name' | grep -E '^(nqrust-manager|nqr-manager)' | head -n1)
          if [[ -n "${MANAGER_ASSET}" ]]; then
            echo "Found manager asset: ${MANAGER_ASSET}"
            download_with_retry "${BASE_URL}/${MANAGER_ASSET}" /tmp/bundle/bin/nqr-manager
          else
            echo "WARNING: No manager binary found in release assets"
          fi
          
          # Find and download installer binary (look for patterns: nqr-installer*, nqrust-installer*)
          echo "=== Downloading installer binary ==="
          INSTALLER_ASSET=$(echo "${ASSETS_JSON}" | jq -r '.assets[].name' | grep -E '^(nqr-installer|nqrust-installer)' | grep -v '\.tar\.gz$' | head -n1)
          if [[ -n "${INSTALLER_ASSET}" ]]; then
            echo "Found installer asset: ${INSTALLER_ASSET}"
            download_with_retry "${BASE_URL}/${INSTALLER_ASSET}" /tmp/bundle/bin/nqr-installer
          else
            echo "WARNING: No installer binary found in release assets"
          fi
          
          # Find and download guest-agent binary (look for patterns: nqrust-guest-agent*, nqr-guest-agent*)
          echo "=== Downloading guest-agent binary ==="
          GUEST_AGENT_ASSET=$(echo "${ASSETS_JSON}" | jq -r '.assets[].name' | grep -E '^(nqrust-guest-agent|nqr-guest-agent)' | head -n1)
          if [[ -n "${GUEST_AGENT_ASSET}" ]]; then
            echo "Found guest-agent asset: ${GUEST_AGENT_ASSET}"
            download_with_retry "${BASE_URL}/${GUEST_AGENT_ASSET}" /tmp/bundle/bin/nqr-guest-agent
          else
            echo "WARNING: No guest-agent binary found in release assets"
          fi
          
          # Find and download host agent binary (look for patterns: nqrust-agent*, nqr-agent*)
          echo "=== Downloading agent binary ==="
          AGENT_ASSET=$(echo "${ASSETS_JSON}" | jq -r '.assets[].name' | grep -E '^(nqrust-agent|nqr-agent)-' | head -n1)
          if [[ -n "${AGENT_ASSET}" ]]; then
            echo "Found agent asset: ${AGENT_ASSET}"
            download_with_retry "${BASE_URL}/${AGENT_ASSET}" /tmp/bundle/bin/nqr-agent
          else
            echo "WARNING: No agent binary found in release assets"
          fi
          
          chmod +x /tmp/bundle/bin/* 2>/dev/null || true
          
          echo ""
          echo "=== Downloaded binaries ==="
          ls -la /tmp/bundle/bin/
          
          # Verify critical binaries exist and are executable
          if [[ ! -x /tmp/bundle/bin/nqr-installer ]]; then
            echo ""
            echo "ERROR: nqr-installer not found or not executable!"
            echo "This is required for the air-gapped installer to work."
            echo ""
            echo "Available assets in release:"
            echo "${ASSETS_JSON}" | jq -r '.assets[].name'
            exit 1
          fi
          
          echo ""
          echo "=== Binary verification ==="
          file /tmp/bundle/bin/* || true

      - name: Download Firecracker
        run: |
          FC_VERSION="v1.13.1"
          FC_URL="https://github.com/firecracker-microvm/firecracker/releases/download/${FC_VERSION}/firecracker-${FC_VERSION}-x86_64.tgz"
          
          curl -fsSL "${FC_URL}" -o /tmp/firecracker.tgz
          tar -xzf /tmp/firecracker.tgz -C /tmp
          
          cp "/tmp/release-${FC_VERSION}-x86_64/firecracker-${FC_VERSION}-x86_64" /tmp/bundle/bin/firecracker
          cp "/tmp/release-${FC_VERSION}-x86_64/jailer-${FC_VERSION}-x86_64" /tmp/bundle/bin/jailer
          
          chmod +x /tmp/bundle/bin/firecracker /tmp/bundle/bin/jailer

      - name: Download images
        run: |
          mkdir -p /tmp/bundle/images/kernel
          mkdir -p /tmp/bundle/images/rootfs
          
          VERSION="${{ steps.version.outputs.version }}"
          
          if [[ "${VERSION}" == "latest" ]]; then
            BASE_URL="https://github.com/${{ github.repository }}/releases/latest/download"
          else
            BASE_URL="https://github.com/${{ github.repository }}/releases/download/${VERSION}"
          fi
          
          echo "=== Downloading kernel images ==="
          # Kernel (matches what's in the release)
          curl -fsSL "${BASE_URL}/vmlinux-5.10.fc.bin" -o /tmp/bundle/images/kernel/vmlinux-5.10.fc.bin || echo "Kernel 5.10 download failed"
          
          echo "=== Downloading rootfs images ==="
          # All rootfs images that are in the release
          ROOTFS_IMAGES=(
            "alpine-3.18-minimal.ext4"
            "busybox-1.35.ext4"
            "ubuntu-24.04-minimal.ext4"
            "python-runtime.ext4"
            "bun-runtime.ext4"
            "node-runtime.ext4"
          )
          
          for img in "${ROOTFS_IMAGES[@]}"; do
            echo "Downloading ${img}..."
            curl -fsSL "${BASE_URL}/${img}" -o "/tmp/bundle/images/rootfs/${img}" || echo "Failed to download ${img}"
          done
          
          # Container runtime (large file, compressed in release)
          echo "Downloading container-runtime.ext4.gz (large file, may take a while)..."
          curl -fsSL "${BASE_URL}/container-runtime.ext4.gz" -o /tmp/bundle/images/rootfs/container-runtime.ext4.gz || echo "Container runtime download failed"
          
          # Decompress if downloaded successfully
          if [[ -f /tmp/bundle/images/rootfs/container-runtime.ext4.gz ]]; then
            echo "Decompressing container-runtime.ext4.gz..."
            gunzip -f /tmp/bundle/images/rootfs/container-runtime.ext4.gz || echo "Decompression failed"
          fi
          
          echo "=== Downloaded images ==="
          ls -la /tmp/bundle/images/kernel/
          ls -la /tmp/bundle/images/rootfs/

      - name: Export Docker images
        run: |
          mkdir -p /tmp/bundle/images/docker
          
          IMAGES=(
            "postgres:16-alpine"
            "redis:7-alpine"
            "nginx:alpine"
            "alpine:latest"
          )
          
          for image in "${IMAGES[@]}"; do
            echo "Exporting ${image}..."
            docker pull "${image}"
            tarball_name=$(echo "${image}" | sed 's/[:\\/]/-/g').tar
            docker save "${image}" -o "/tmp/bundle/images/docker/${tarball_name}"
            echo "Exported: ${tarball_name}"
          done
          
          ls -la /tmp/bundle/images/docker/

      - name: Build ISO
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          
          # Set up live-build
          mkdir -p /tmp/iso-build
          cd /tmp/iso-build
          
          # Use Debian mode explicitly (not Ubuntu) for bookworm
          # Specify linux-flavours and linux-packages to avoid Contents file lookup
          # Disable firmware-chroot to prevent downloading Contents-amd64.gz (404)
          lb config \
            --mode debian \
            --system live \
            --architecture amd64 \
            --distribution bookworm \
            --binary-images iso-hybrid \
            --bootloader syslinux \
            --debian-installer false \
            --memtest none \
            --source false \
            --bootappend-live "boot=live components quiet splash live-config.username=root live-config.user-fullname=Root live-config.user-default-groups=sudo,audio,video,cdrom,plugdev live-config.noroot=false" \
            --apt-indices false \
            --apt-recommends false \
            --linux-flavours "amd64" \
            --linux-packages "linux-image" \
            --firmware-chroot false \
            --firmware-binary false \
            --archive-areas "main contrib non-free non-free-firmware" \
            --mirror-bootstrap "http://deb.debian.org/debian" \
            --mirror-chroot "http://deb.debian.org/debian" \
            --mirror-binary "http://deb.debian.org/debian" \
            --security false \
            --iso-application "NQR-MicroVM Installer" \
            --iso-preparer "Nexus" \
            --iso-publisher "Nexus" \
            --iso-volume "NQR-MicroVM"
          
          # Package lists
          mkdir -p config/package-lists
          
          cat > config/package-lists/base.list.chroot << 'EOF'
          linux-image-amd64
          live-boot
          systemd
          systemd-sysv
          dbus
          locales
          console-setup
          kbd
          iproute2
          iptables
          bridge-utils
          net-tools
          iputils-ping
          openssh-server
          openssh-client
          curl
          wget
          lvm2
          parted
          fdisk
          gdisk
          e2fsprogs
          xfsprogs
          dosfstools
          ncurses-term
          dialog
          tmux
          sudo
          vim-tiny
          less
          ca-certificates
          gnupg
          postgresql
          postgresql-client
          syslinux
          syslinux-common
          syslinux-utils
          isolinux
          EOF
          
          # Fix bootloader symlinks - the default live-build bootloader config has broken symlinks
          # Create a custom bootloader config with correct paths
          mkdir -p config/bootloaders/isolinux
          
          # Copy the actual binary files (not symlinks) with correct paths
          cp /usr/lib/ISOLINUX/isolinux.bin config/bootloaders/isolinux/
          cp /usr/lib/syslinux/modules/bios/menu.c32 config/bootloaders/isolinux/
          cp /usr/lib/syslinux/modules/bios/ldlinux.c32 config/bootloaders/isolinux/
          cp /usr/lib/syslinux/modules/bios/libcom32.c32 config/bootloaders/isolinux/
          cp /usr/lib/syslinux/modules/bios/libutil.c32 config/bootloaders/isolinux/
          
          # Create empty bootlogo archive (live-build requires this file even if unused)
          mkdir -p /tmp/bootlogo-tmp
          touch /tmp/bootlogo-tmp/placeholder
          (cd /tmp/bootlogo-tmp && echo placeholder | cpio --quiet -o) > config/bootloaders/isolinux/bootlogo
          rm -rf /tmp/bootlogo-tmp
          
          # Create simple text-based menu config (avoids vesamenu/bootlogo/rsvg issues)
          cat > config/bootloaders/isolinux/isolinux.cfg << 'ISOCFG'
          ui menu.c32
          prompt 0
          timeout 50
          
          menu title NQR-MicroVM Installer
          
          label live
            menu label ^Start NQR-MicroVM Installer
            menu default
            linux /live/vmlinuz
            initrd /live/initrd.img
            append boot=live components quiet splash
          
          label live-failsafe
            menu label Start in ^Safe Mode
            linux /live/vmlinuz
            initrd /live/initrd.img
            append boot=live components memtest noapic noapm nodma nomce nolapic nomodeset nosmp nosplash vga=normal
          ISOCFG
          
          # Create live.cfg.in for kernel version substitution
          cat > config/bootloaders/isolinux/live.cfg.in << 'LIVECFG'
          label live
            menu label ^Start NQR-MicroVM Installer
            menu default
            linux /live/vmlinuz
            initrd /live/initrd.img
            append boot=live components quiet splash
          LIVECFG
          
          # Include bundle
          mkdir -p config/includes.chroot/opt/nqrust-bundle
          cp -r /tmp/bundle/* config/includes.chroot/opt/nqrust-bundle/
          
          # Create first-boot service
          mkdir -p config/includes.chroot/etc/systemd/system
          cp ${{ github.workspace }}/scripts/iso/files/nqrust-firstboot.service \
            config/includes.chroot/etc/systemd/system/
          
          mkdir -p config/includes.chroot/etc/systemd/system/multi-user.target.wants
          ln -sf ../nqrust-firstboot.service \
            config/includes.chroot/etc/systemd/system/multi-user.target.wants/nqrust-firstboot.service
          
          # For sysvinit: Configure auto-login via inittab modification hook
          # (The systemd config is ignored when using sysvinit)
          mkdir -p config/includes.chroot/etc/systemd/system/getty@tty1.service.d
          cat > config/includes.chroot/etc/systemd/system/getty@tty1.service.d/autologin.conf << 'EOF'
          [Service]
          ExecStart=
          ExecStart=-/sbin/agetty --autologin root --noclear %I $TERM
          EOF
          
          # Create sysvinit inittab for auto-login (live-boot uses sysvinit, not systemd)
          cat > config/includes.chroot/etc/inittab << 'INITTAB'
          # /etc/inittab: init(8) configuration for NQR-MicroVM Installer
          # Auto-login on tty1 for installer
          
          # Default runlevel
          id:2:initdefault:
          
          # System initialization
          si::sysinit:/etc/init.d/rcS
          
          # Runlevels
          l0:0:wait:/etc/init.d/rc 0
          l1:1:wait:/etc/init.d/rc 1
          l2:2:wait:/etc/init.d/rc 2
          l3:3:wait:/etc/init.d/rc 3
          l4:4:wait:/etc/init.d/rc 4
          l5:5:wait:/etc/init.d/rc 5
          l6:6:wait:/etc/init.d/rc 6
          
          # Ctrl-Alt-Del
          ca:12345:ctrlaltdel:/sbin/shutdown -t1 -a -r now
          
          # Power management
          pf::powerwait:/etc/init.d/powerfail start
          pn::powerfailnow:/etc/init.d/powerfail now
          po::powerokwait:/etc/init.d/powerfail stop
          
          # TTY1 with AUTO-LOGIN as root
          1:2345:respawn:/sbin/agetty --autologin root --noclear tty1 linux
          
          # Other TTYs - normal login
          2:23:respawn:/sbin/getty 38400 tty2
          3:23:respawn:/sbin/getty 38400 tty3
          4:23:respawn:/sbin/getty 38400 tty4
          5:23:respawn:/sbin/getty 38400 tty5
          6:23:respawn:/sbin/getty 38400 tty6
          INITTAB
          
          # Also create .profile for sh compatibility (some shells read this instead of .bash_profile)
          mkdir -p config/includes.chroot/root
          cat > config/includes.chroot/root/.profile << 'PROFILE'
          # NQR-MicroVM Installer Auto-Launch
          # Only run on tty1 and if installer hasn't run yet
          if [ "$(tty)" = "/dev/tty1" ] && [ ! -f /var/lib/nqrust-installed ]; then
            echo ""
            echo "Starting NQR-MicroVM Installer..."
            echo ""
            sleep 1
            if [ -x /opt/nqrust-bundle/bin/nqr-installer ]; then
              /opt/nqrust-bundle/bin/nqr-installer install --iso-mode --bundle-path /opt/nqrust-bundle
              touch /var/lib/nqrust-installed
            fi
          fi
          PROFILE
          
          # Auto-start installer when root logs in on tty1
          cat > config/includes.chroot/root/.bash_profile << 'BASHPROFILE'
          #!/bin/bash
          # Auto-start installer on first boot (only on tty1)
          if [ "$(tty)" = "/dev/tty1" ] && [ ! -f /var/lib/nqrust-installed ]; then
            clear
            echo ""
            echo "  ╔════════════════════════════════════════════════════════════╗"
            echo "  ║           NQR-MicroVM Air-Gapped Installer                 ║"
            echo "  ╚════════════════════════════════════════════════════════════╝"
            echo ""
            
            if [ -x /opt/nqrust-bundle/bin/nqr-installer ]; then
              echo "Starting installer..."
              sleep 2
              /opt/nqrust-bundle/bin/nqr-installer install --iso-mode --bundle-path /opt/nqrust-bundle
              touch /var/lib/nqrust-installed
            else
              echo "WARNING: Installer binary not found!"
              echo ""
              echo "Available files in bundle:"
              ls -la /opt/nqrust-bundle/bin/ 2>/dev/null || echo "  (none)"
              echo ""
              echo "You can manually install by running the installer once it's available."
              echo "Press Enter to continue to shell..."
              read
            fi
          fi
          BASHPROFILE
          
          # MOTD
          cat > config/includes.chroot/etc/motd << EOF
          
              _   _  ___  ____       __  __ _               __     ____  __
             | \ | |/ _ \|  _ \     |  \/  (_) ___ _ __ ___\ \   / /  \/  |
             |  \| | | | | |_) |____| |\/| | |/ __| '__/ _ \\ \ / /| |\/| |
             | |\  | |_| |  _ <_____| |  | | | (__| | | (_) |\ V / | |  | |
             |_| \_|\__\_\_| \_\    |_|  |_|_|\___|_|  \___/  \_/  |_|  |_|
          
             Air-Gapped Installer ${VERSION}
             
             The installer will start automatically on first boot.
             For manual installation, run: /opt/nqrust-bundle/bin/nqr-installer install --iso-mode
          
          EOF
          
          # Build hook - works with both systemd and sysvinit
          mkdir -p config/hooks/live
          cat > config/hooks/live/9999-setup.hook.chroot << 'EOF'
          #!/bin/bash
          set -e
          ln -sf /usr/share/zoneinfo/UTC /etc/localtime
          echo "KEYMAP=us" > /etc/vconsole.conf
          
          # Set root password - use direct shadow file modification for reliability
          # Generate password hash for 'nqrust'
          HASH=$(echo 'nqrust' | openssl passwd -6 -stdin)
          # Update root's password in shadow file
          sed -i "s|^root:[^:]*:|root:${HASH}:|" /etc/shadow
          
          # Ensure root account is not locked
          sed -i 's/^root:!/root:/' /etc/shadow
          passwd -u root 2>/dev/null || true
          
          # Create 'live' user as fallback (password: live)
          useradd -m -s /bin/bash live 2>/dev/null || true
          LIVE_HASH=$(echo 'live' | openssl passwd -6 -stdin)
          sed -i "s|^live:[^:]*:|live:${LIVE_HASH}:|" /etc/shadow || true
          
          # Enable SSH (works with both systemd and sysvinit)
          if command -v systemctl >/dev/null 2>&1; then
            systemctl enable ssh 2>/dev/null || true
          else
            update-rc.d ssh defaults 2>/dev/null || true
          fi
          
          # Allow root login via SSH
          sed -i 's/#PermitRootLogin.*/PermitRootLogin yes/' /etc/ssh/sshd_config 2>/dev/null || true
          sed -i 's/PermitRootLogin.*/PermitRootLogin yes/' /etc/ssh/sshd_config 2>/dev/null || true
          
          # Configure auto-login for sysvinit (modify inittab)
          if [ -f /etc/inittab ]; then
            # Replace the tty1 getty line with auto-login version
            sed -i 's|^1:2345:respawn:/sbin/getty.*tty1|1:2345:respawn:/sbin/getty --autologin root 38400 tty1|' /etc/inittab
            # Also try alternative format
            sed -i 's|^1:23:respawn:/sbin/getty.*tty1|1:23:respawn:/sbin/getty --autologin root 38400 tty1|' /etc/inittab
          fi
          
          chmod +x /opt/nqrust-bundle/bin/* 2>/dev/null || true
          ln -sf /opt/nqrust-bundle/bin/nqr-installer /usr/local/bin/nqr-installer 2>/dev/null || true
          ln -sf /opt/nqrust-bundle/bin/nqr-manager /usr/local/bin/nqr-manager 2>/dev/null || true
          EOF
          chmod +x config/hooks/live/9999-setup.hook.chroot
          
          # Explicitly disable source build in config
          mkdir -p config
          echo 'LB_SOURCE="false"' > config/source
          
          # Build - ignore exit code since lb_source may fail even though ISO is built
          sudo lb build 2>&1 | tee build.log || true
          
          # Check if ISO was created (the important part)
          echo "=== Build directory contents ==="
          ls -la
          echo "=== Looking for ISO files ==="
          find . -name "*.iso" -type f 2>/dev/null || true
          
          # Find the ISO file - live-build may use different naming patterns
          ISO_FILE=$(find . -maxdepth 1 -name "*.hybrid.iso" -type f 2>/dev/null | head -n1)
          
          # If not found at top level, check common subdirectories
          if [[ -z "${ISO_FILE}" ]]; then
            ISO_FILE=$(find . -name "*.hybrid.iso" -type f 2>/dev/null | head -n1)
          fi
          
          # Also check for non-hybrid ISOs as fallback
          if [[ -z "${ISO_FILE}" ]]; then
            ISO_FILE=$(find . -name "*.iso" -type f 2>/dev/null | head -n1)
          fi
          
          if [[ -n "${ISO_FILE}" && -f "${ISO_FILE}" ]]; then
            echo "ISO built successfully: ${ISO_FILE}"
            ls -lh "${ISO_FILE}"
            # Rename to expected name if different
            if [[ "${ISO_FILE}" != "./live-image-amd64.hybrid.iso" ]]; then
              echo "Renaming ${ISO_FILE} to live-image-amd64.hybrid.iso"
              mv "${ISO_FILE}" live-image-amd64.hybrid.iso
            fi
          else
            echo "ISO file not found after build"
            echo "=== Full directory tree ==="
            find . -name "*.iso" -o -name "*.img" 2>/dev/null || true
            echo "=== Last 100 lines of build log ==="
            tail -100 build.log
            exit 1
          fi

      - name: Rename and create checksums
        id: iso
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          ISO_NAME="nqr-microvm-${VERSION}-airgap-amd64.iso"
          
          cd /tmp/iso-build
          
          if [[ -f "live-image-amd64.hybrid.iso" ]]; then
            mv live-image-amd64.hybrid.iso "${ISO_NAME}"
            
            # Generate checksums
            sha256sum "${ISO_NAME}" > "${ISO_NAME}.sha256"
            md5sum "${ISO_NAME}" > "${ISO_NAME}.md5"
            
            echo "iso_name=${ISO_NAME}" >> $GITHUB_OUTPUT
            echo "iso_path=/tmp/iso-build/${ISO_NAME}" >> $GITHUB_OUTPUT
            
            ls -lh "${ISO_NAME}"
          else
            echo "ISO build failed!"
            cat build.log
            exit 1
          fi

      - name: Upload ISO artifact
        uses: actions/upload-artifact@v4
        with:
          name: nqr-microvm-airgap-iso
          path: |
            /tmp/iso-build/${{ steps.iso.outputs.iso_name }}
            /tmp/iso-build/${{ steps.iso.outputs.iso_name }}.sha256
            /tmp/iso-build/${{ steps.iso.outputs.iso_name }}.md5
          retention-days: 30

      - name: Upload to release
        if: github.event_name == 'workflow_run' || (github.event_name == 'workflow_dispatch' && github.event.inputs.release_version != 'latest')
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.version }}
          files: |
            /tmp/iso-build/${{ steps.iso.outputs.iso_name }}
            /tmp/iso-build/${{ steps.iso.outputs.iso_name }}.sha256
            /tmp/iso-build/${{ steps.iso.outputs.iso_name }}.md5
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload build log on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: iso-build-log
          path: /tmp/iso-build/build.log
          retention-days: 7
