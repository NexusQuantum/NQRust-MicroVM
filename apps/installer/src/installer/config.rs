//! Configuration file generation module.

use std::path::Path;

use anyhow::Result;

use crate::app::{InstallConfig, LogEntry};
use crate::installer::{run_command, run_sudo};

/// Generate all configuration files
pub fn generate_config(config: &InstallConfig, db_password: &str) -> Result<Vec<LogEntry>> {
    let mut logs = Vec::new();

    let config_dir = &config.config_dir;

    logs.push(LogEntry::info(format!(
        "Generating configuration in {}...",
        config_dir.display()
    )));

    // Create config directory
    let _ = run_sudo("mkdir", &["-p", &config_dir.display().to_string()]);

    // Generate manager config if needed
    if config.mode.includes_manager() {
        logs.extend(generate_manager_config(config, db_password)?);
    }

    // Generate agent config if needed
    if config.mode.includes_agent() {
        logs.extend(generate_agent_config(config)?);
    }

    // Generate UI config if needed
    if config.mode.includes_ui() {
        logs.extend(generate_ui_config(config)?);
    }

    // Generate unified YAML config
    logs.extend(generate_yaml_config(config, db_password)?);

    // Set permissions
    let _ = run_sudo("chmod", &["700", &config_dir.display().to_string()]);
    let _ = run_sudo(
        "chown",
        &["-R", "root:root", &config_dir.display().to_string()],
    );

    logs.push(LogEntry::success("Configuration generated"));

    Ok(logs)
}

/// Generate manager environment file
fn generate_manager_config(config: &InstallConfig, db_password: &str) -> Result<Vec<LogEntry>> {
    let mut logs = Vec::new();

    let db_url = format!(
        "postgresql://{}:{}@{}:{}/{}",
        config.db_user, db_password, config.db_host, config.db_port, config.db_name
    );

    // IMPORTANT: These settings are REQUIRED for proper operation (not just dev mode)
    // - ALLOW_IMAGE_PATHS=true: Required for functions/containers to work properly
    // - RECONCILER_DISABLED=1: Reconciler causes race conditions and VM creation failures
    // Only difference in dev mode is the log level
    let rust_log = if config.mode == crate::app::InstallMode::Development {
        "debug"
    } else {
        "info"
    };

    let env_content = format!(
        r#"# NQR-MicroVM Manager Configuration
# Generated by nqr-installer
# Mode: {}

# Database
DATABASE_URL={}

# Server binding
MANAGER_BIND=0.0.0.0:18080

# Storage paths
# NOTE: Using /srv/images (not {}/images) because functions/containers have hardcoded /srv/images paths
MANAGER_IMAGE_ROOT=/srv/images
MANAGER_STORAGE_ROOT={}/vms

# Allow direct file paths for images (REQUIRED for functions/containers)
MANAGER_ALLOW_IMAGE_PATHS=true

# Disable VM reconciler (REQUIRED - causes race conditions if enabled)
MANAGER_RECONCILER_DISABLED=1

# Host registration
MANAGER_HOST_ID=
MANAGER_BRIDGE={}

# Logging
RUST_LOG={}
"#,
        config.mode.name(),
        db_url,
        config.data_dir.display(),
        config.data_dir.display(),
        config.bridge_name,
        rust_log
    );

    let env_file = config.config_dir.join("manager.env");
    write_config_file(&env_file, &env_content)?;
    logs.push(LogEntry::success("Manager configuration generated"));

    Ok(logs)
}

/// Generate agent environment file
fn generate_agent_config(config: &InstallConfig) -> Result<Vec<LogEntry>> {
    let mut logs = Vec::new();

    // Set debug log level for development mode
    let rust_log = if config.mode == crate::app::InstallMode::Development {
        "debug"
    } else {
        "info"
    };

    let env_content = format!(
        r#"# NQR-MicroVM Agent Configuration
# Generated by nqr-installer
# Mode: {}

# Server binding (listen on all interfaces)
AGENT_BIND=0.0.0.0:9090

# Advertise address - this is how the manager reaches this agent
# Using 127.0.0.1 for local-only installation (manager and agent on same machine)
AGENT_ADVERTISE_ADDR=http://127.0.0.1:9090

# Firecracker runtime directory
FC_RUN_DIR={}

# Network bridge
FC_BRIDGE={}

# Manager API URL
MANAGER_BASE=http://127.0.0.1:18080

# Logging
RUST_LOG={}
"#,
        config.mode.name(),
        config.data_dir.display(),
        config.bridge_name,
        rust_log
    );

    let env_file = config.config_dir.join("agent.env");
    write_config_file(&env_file, &env_content)?;
    logs.push(LogEntry::success("Agent configuration generated"));

    Ok(logs)
}

/// Generate UI environment file
fn generate_ui_config(config: &InstallConfig) -> Result<Vec<LogEntry>> {
    let mut logs = Vec::new();

    // NOTE: Don't set NEXT_PUBLIC_API_BASE_URL or NEXT_PUBLIC_WS_BASE_URL here
    // Let the UI use default values which work for remote access via proxy
    // The UI will proxy API requests through Next.js and construct WebSocket URLs dynamically
    let env_content = r#"# NQR-MicroVM UI Configuration
# Generated by nqr-installer

# Theme
NEXT_PUBLIC_BRAND_PRESET=dark

# API and WebSocket URLs are intentionally NOT set here
# The UI will use defaults that work for remote access:
# - API: http://localhost:18080/v1 (works with window.location)
# - WebSocket: ws://localhost:18080 (works with window.location)
#
# The UI code will replace 'localhost' with window.location.hostname in the browser
# This allows remote access to work correctly
"#;

    let env_file = config.config_dir.join("ui.env");
    write_config_file(&env_file, env_content)?;
    logs.push(LogEntry::success("UI configuration generated"));

    Ok(logs)
}

/// Generate unified YAML configuration
fn generate_yaml_config(config: &InstallConfig, _db_password: &str) -> Result<Vec<LogEntry>> {
    let mut logs = Vec::new();

    let yaml_content = format!(
        r#"# NQR-MicroVM Configuration
# Generated by nqr-installer

installation:
  mode: {}
  install_dir: {}
  data_dir: {}
  config_dir: {}
  log_dir: {}

manager:
  bind: "0.0.0.0:18080"
  database:
    host: {}
    port: {}
    name: {}
    user: {}
    # password stored securely in manager.env
  storage:
    image_root: "{}/images"
    vm_root: "{}/vms"

agent:
  bind: "0.0.0.0:9090"
  firecracker:
    run_dir: {}
    bridge: {}
  manager_url: "http://127.0.0.1:18080"

network:
  mode: {}
  bridge: {}

ui:
  enabled: {}
  api_url: "http://127.0.0.1:18080/v1"
"#,
        config.mode.name().to_lowercase().replace(' ', "_"),
        config.install_dir.display(),
        config.data_dir.display(),
        config.config_dir.display(),
        config.log_dir.display(),
        config.db_host,
        config.db_port,
        config.db_name,
        config.db_user,
        config.data_dir.display(),
        config.data_dir.display(),
        config.data_dir.display(),
        config.bridge_name,
        config.network_mode.name().to_lowercase(),
        config.bridge_name,
        config.mode.includes_ui()
    );

    let yaml_file = config.config_dir.join("config.yaml");
    write_config_file(&yaml_file, &yaml_content)?;
    logs.push(LogEntry::success("YAML configuration generated"));

    Ok(logs)
}

/// Write a configuration file with sudo
fn write_config_file(path: &Path, content: &str) -> Result<()> {
    let cmd = format!(
        "echo '{}' | sudo tee {} > /dev/null",
        content.replace('\'', "'\"'\"'"),
        path.display()
    );
    run_command("sh", &["-c", &cmd])?;

    // Set permissions
    let _ = run_sudo("chmod", &["600", &path.display().to_string()]);

    Ok(())
}

/// Create system user for running services
pub fn create_system_user() -> Result<Vec<LogEntry>> {
    let mut logs = Vec::new();

    logs.push(LogEntry::info("Creating system user 'nqrust'..."));

    // Check if user exists
    let output = run_command("id", &["nqrust"]);
    if let Ok(out) = output {
        if out.status.success() {
            logs.push(LogEntry::info("User 'nqrust' already exists"));

            // Still add to groups in case they were created after user
            let _ = run_sudo("usermod", &["-aG", "kvm", "nqrust"]);

            // Add to docker group if it exists (for container feature)
            if run_command("getent", &["group", "docker"])
                .map(|o| o.status.success())
                .unwrap_or(false)
            {
                let _ = run_sudo("usermod", &["-aG", "docker", "nqrust"]);
                logs.push(LogEntry::info("Added nqrust to docker group"));
            }

            return Ok(logs);
        }
    }

    // Determine groups to add user to
    let mut groups = vec!["kvm"];

    // Check if docker group exists
    let docker_group_exists = run_command("getent", &["group", "docker"])
        .map(|o| o.status.success())
        .unwrap_or(false);

    if docker_group_exists {
        groups.push("docker");
    }

    let groups_str = groups.join(",");

    // Create user with groups
    let output = run_sudo(
        "useradd",
        &[
            "--system",
            "--no-create-home",
            "--shell",
            "/usr/sbin/nologin",
            "--groups",
            &groups_str,
            "nqrust",
        ],
    )?;

    if output.status.success() {
        logs.push(LogEntry::success(&format!(
            "System user 'nqrust' created with groups: {}",
            groups_str
        )));
    } else {
        logs.push(LogEntry::warning(
            "Failed to create user, may already exist",
        ));
    }

    Ok(logs)
}

/// Create required directories
pub fn create_directories(config: &InstallConfig) -> Result<Vec<LogEntry>> {
    let mut logs = Vec::new();

    // Core directories
    let dirs = [
        config.install_dir.clone(),
        config.install_dir.join("bin"),
        config.data_dir.clone(),
        config.data_dir.join("vms"),
        config.config_dir.clone(),
        config.log_dir.clone(),
    ];

    for dir in &dirs {
        let _ = run_sudo("mkdir", &["-p", &dir.display().to_string()]);
    }

    // Image directories - needs to be writable by nqrust for function runtime copies
    let image_dirs = [
        "/srv/images",
        "/srv/images/functions",
        "/srv/images/containers",
    ];

    for dir in &image_dirs {
        let _ = run_sudo("mkdir", &["-p", dir]);
    }

    // Set ownership for data directories
    let _ = run_sudo(
        "chown",
        &[
            "-R",
            "nqrust:nqrust",
            &config.data_dir.display().to_string(),
        ],
    );

    // Set ownership for image directories (needed for function runtime copies)
    let _ = run_sudo("chown", &["-R", "nqrust:nqrust", "/srv/images"]);

    logs.push(LogEntry::success("Directories created"));

    Ok(logs)
}

/// Setup sudoers configuration for nqrust user
/// This allows the manager to run mount/umount commands for guest agent installation
pub fn setup_sudoers() -> Result<Vec<LogEntry>> {
    let mut logs = Vec::new();

    logs.push(LogEntry::info("Setting up sudoers for nqrust user..."));

    // Sudoers content - allows manager to mount/umount rootfs for guest agent installation
    let sudoers_content = r#"# Sudoers configuration for NQRust-MicroVM
# This file grants necessary sudo permissions to manager and agent

# Manager commands (for rootfs operations - guest agent installation)
Cmnd_Alias MANAGER_MOUNT = /bin/mount, /bin/umount, /usr/bin/mount, /usr/bin/umount
Cmnd_Alias MANAGER_FILE_OPS = /bin/cp, /bin/mv, /bin/chmod, /bin/chown, /bin/mkdir, /bin/rmdir, /bin/ln, /bin/rm, /bin/touch, /usr/bin/touch
Cmnd_Alias MANAGER_TEST = /bin/test, /usr/bin/test, /bin/ls, /usr/bin/ls
Cmnd_Alias MANAGER_READ = /bin/cat, /usr/bin/cat
Cmnd_Alias MANAGER_WRITE = /usr/bin/tee, /bin/tee, /bin/dd

# Agent commands (needs more permissions for Firecracker and networking)
Cmnd_Alias AGENT_FIRECRACKER = /usr/local/bin/firecracker, /usr/bin/firecracker
Cmnd_Alias AGENT_NETWORK = /usr/sbin/ip, /sbin/ip, /usr/bin/brctl, /sbin/brctl
Cmnd_Alias AGENT_SYSTEMD = /usr/bin/systemd-run, /bin/systemd-run, /usr/bin/systemctl, /bin/systemctl
Cmnd_Alias AGENT_SCREEN = /usr/bin/screen, /bin/screen

# Allow nqrust user to run manager commands without password
nqrust ALL=(ALL) NOPASSWD: MANAGER_MOUNT, MANAGER_FILE_OPS, MANAGER_TEST, MANAGER_READ, MANAGER_WRITE

# Agent runs as root in systemd service, but allow group access for manual testing
%nqrust ALL=(ALL) NOPASSWD: AGENT_FIRECRACKER, AGENT_NETWORK, AGENT_SYSTEMD, AGENT_SCREEN

# Prevent password prompt timeout
Defaults:nqrust !authenticate
"#;

    let sudoers_path = "/etc/sudoers.d/nqrust";

    // Write sudoers file
    let cmd = format!(
        "echo '{}' | sudo tee {} > /dev/null",
        sudoers_content.replace('\'', "'\"'\"'"),
        sudoers_path
    );

    match run_command("sh", &["-c", &cmd]) {
        Ok(output) => {
            if !output.status.success() {
                logs.push(LogEntry::warning("Failed to write sudoers file"));
                return Ok(logs);
            }
        }
        Err(e) => {
            logs.push(LogEntry::warning(format!(
                "Failed to write sudoers file: {}",
                e
            )));
            return Ok(logs);
        }
    }

    // Set correct permissions (sudoers files MUST be 0440)
    let _ = run_sudo("chmod", &["0440", sudoers_path]);
    let _ = run_sudo("chown", &["root:root", sudoers_path]);

    // Validate the sudoers file
    match run_sudo("visudo", &["-c", "-f", sudoers_path]) {
        Ok(output) => {
            if output.status.success() {
                logs.push(LogEntry::success(
                    "Sudoers configuration installed and validated",
                ));
            } else {
                // Invalid sudoers file - remove it to prevent lockout
                let _ = run_sudo("rm", &[sudoers_path]);
                logs.push(LogEntry::warning(
                    "Sudoers file had invalid syntax, removed for safety",
                ));
            }
        }
        Err(_) => {
            logs.push(LogEntry::warning("Could not validate sudoers file"));
        }
    }

    Ok(logs)
}
